\input{../preambule.tex}

\title{Modal logic, $\mu$-calcul, parity games and others}
\author{Diego Dorn}

\newcommand{\infiniteWords}{\infseq{(\IB^n)}}

\begin{document}

\maketitle

\section{Beyond first order logic}

The goal of this section is to introduce the reader
to some extensions of first order logic (FO),
and most importantly to develop monadic second order logic.

\subsection{Second order logic}

In first order logic, quantifications happen only over the
domain elements.
Second order logic (SO) is a generalization of FO,
where quantification over relations are allowed.
It adds second order variables, usually denoted by capital
letters, that are interpreted by relations, that is,
if the relation is of arity $n$, subsets of $\Mm^n$.

For instance, the following formula are syntaxically valid:
\begin{itemize}
    % \item $\forall P~ \exists x~ \forall y~ P(x) \implies P(y)$,
    %     where $P$ is a variable of arity $1$.
    \item If the language contains the symbol $\leq$
        and $A$ is a second order variable of arity 1, then:
    \[
        \forall A ~ \exists x ~
            (A(x) \implies \forall y ~
                (A(y) \implies x \leq y)
    \]
        is a formula expressing that every subset of the model
        a has a minimal element.
    \item If the language contains a binary relation $E$
        and $M$ is a second order variable of arity 2,
        consider
        \[
            \exists M\, \forall x\, \forall y \,
            \bigparenthesis{M(x, y) \implies E(x, y)}
            \wedge \forall x \, \exists! y \, M(x, y).
        \]
        If $E$ is symetrical, we can view any model as an
        undirected graph with edges given by $E$, then
        the formula above express the fact that
        there exists a perfect matching, namely $M$.
\end{itemize}

\begin{definition}
    Given a vocabulary $\sigma$ consisting of relations
    and constants symbols,
    the \emph{terms} of SO are constants symbols and first order variables.

    The \emph{atomic formulas} are of the form:
    \begin{itemize}
        \item $t = t'$ when $t, t'$ are terms.
        \item $R(t_1, \dots, t_n)$ when $t_1, \dots, t_n$ are terms
            and $R \in \sigma$ is a relation of arity $n$.
        \item $X(t_1, \dots, t_n)$ when $t_1, \dots, t_n$ are terms
            and $X$ is a second-order variable of arity $n$.
    \end{itemize}

    The set of SO \emph{formulas} is the smallest set that contains
    all atomic formulas and is closed under:
    \begin{itemize}
        \item boolean operators: $\neg$, $\wedge$, $\vee$ and first order quantification
        \item second order quantification: if $\phi(\vec{x}, Y, \vec{X})$
            is a SO formula, then $\forall Y \phi(\vec{x}, Y, \vec{X})$
            and $\exists Y \phi(\vec{x}, Y, \vec{X})$ are SO formulas.
    \end{itemize}

    The \emph{semantic} of SO logic is defined similarly to FO logic
    so we only need to define the semantic for new constructs.
    Let $\Mm$ be a $\s$-structure and $\phi(x_1, \dots, x_k, X_1, \dots, X_n)$
    a SO formula. We define $\Mm \models \phi(\vec{b}, \vec{B})$
    where $b \in \Mm^k$ is a tuple of elements of $\Mm$
    and if $X_i$ is of arity $n_i$, then $B_i$ is a subset of $\Mm^{n_i}$.

    \begin{itemize}
        \item If $\phi(x_1, \dots, x_k, X)$ is $X(t_1, \dots, t_n)$
            with $X$ a second-order variable of arity $n$
            and $t_1, \dots, t_n$ terms with free variables
            among $x_1, \dots, x_i$, then
            $\Mm \models \phi(\vec{b}, B)$
            if $(t_1^\Mm\vec{b}), \dots, t_k^\Mm(\vec{b}))$ is in $B$.
        \item If $\phi(\vec{x}, Y, \vec{X})$ is $\forall Y \psi(\vec{x}, Y, \vec{X})$
            with $Y$ a second-order variable of arity $n$
            then $\Mm \models \phi(\vec{b}, B)$
            if for all $C \subseteq \Mm^n$, $\Mm \models \psi(\vec{x}, C, \vec{X})$
        \item If $\phi(\vec{x}, Y, \vec{X})$ is $\exists Y \psi(\vec{x}, Y, \vec{X})$
            with $Y$ a second-order variable of arity $n$
            then $\Mm \models \phi(\vec{b}, B)$
            if for some $C \subseteq \Mm^n$, $\Mm \models \psi(\vec{x}, C, \vec{X})$
    \end{itemize}
\end{definition}

We will not study much of second order logic, but instead
look at one of its fragment, monadic second order logic.

\subsection{Monadic second order logic}

Monadic second order logic, or MSO is an extension of
fisrt order logic and a restriction of second order logic.
In MSO, valid formulas are formulas of second order logic
where second order quantification happens only on unary relations.
This corresponds to be able to quantify over elements
of the domain (first-order quantification)
or over subsets of the domain (second-order quantification).

The semantics of MSO are the same as SO semantics.

% There are two things that are remarkable about
% this logic, when considered together:
% \begin{itemize}
%     \item MSO is very expressive. It can for instance
%         describe problems at every level of the polynomial hierarchy ($\PHierachy$).
%     \item MSO is decidable for a large class of models, for instance
%         infinte strings and trees.
% \end{itemize}


\subsection{S1S: infinite strings in MSO}

The decidability problem for monadic second order logic
in general is impossible, because it contains first order logic.
However, in monadic second order logic, the theory of \N with
the successor (S1S) has been shown to be decidable.
This theory is also called the theory of inifinite strings
for reasons that will be clear in the next section.

\begin{definition}
    Let $n \in \N$ be a positive integer.
    A \emph{language}  of S1S is $\Ll = \set{\Symbol{0}, \Symbol{S}, \Symbol{<}, \Symbol{P_1}, ..., \Symbol{P_n}}$,
    where $0$ is a constant symbol, $S$ is a unary function,
    $<$ is a binary relation, and the $P_i$ are unary relations.

    Let $P_1, \dots, P_n \subset \N$. A model of S1S is
    $\Mm = \set{\N, 0, +1, <, P_1, ..., P_n}$,
    where the domain is always \N, $S^\Mm = +1$ is the successor function
    which maps $x$ to $x+1$, $<^\Mm = <$ is interpreted as the usual order
    on \N, and $P_i^\Mm = P_i$.

\end{definition}

\begin{remark}
To get a model of S1S, we only need to give the sets $P_1, \dots, P_n$.
Therefore, a model can be coded by an \w-word $\Pp \in \infseq{(\IB^n)}$
where $i \in P_k \iff (\Pp_i)_k = 1$.

In other words, each letter of the \w-word $\Pp$ is a $n$-tuple of
$0$'s and $1$'s, and if the $k$-th element of $i$-th letter is a 1,
then $P_i(k)$ holds.
\end{remark}

The reason why S1S is often called the theory of infinite strings
is because if for each $i \in \N$, there is exactly
one of the $\P_1(i), \dots, P_n(i)$, then
we can represent the model as an infinite string
on the alphabet $\Sigma = \set{P_1, \dots, P_n}$.

\paragraph{}
The semantics of S1S are the same as MSO. In particular,
we use \N as the universe for first order variables
and $2^\N$ as the universe for second order variables.
If $w \in \infiniteWords$ is an infinite word inducing
the model $\Mm = \set{\N, 0, +1, <, P_1, ..., P_n}$,
and $\phi(X_1, \dots, X_n)$
is a S1S formula with $n$ free second order variables,
we write \[
    w \models \phi(X_1, \dots, X_n)
    ~~\iff~~
    \Mm \models \phi_{[P_1/X_1, \dots, P_n/X_n]}
\]

\begin{definition}
    An \w-language $L \subset \infseq{(\IB^n)}$ is
    \emph{S1S-definable} if there is some S1S formula
    $\phi(X_1, \dots, X_n)$ such that
\[
    L = \setst{w \in \infseq{(\IB^n)}}{
        w \models \phi(X_1, \dots, X_n)
    }
\]
\end{definition}

\begin{example}
    $L = \setst{w \in \infseq{\IB}}{w \text{ has infinitly many 1's}}$
    is first order definable by
    $\phi(X_1) = \forall s\, \exists t\, (s < t \wedge X_1(t))$
\end{example}




\begin{definition}
    A \emph{Büchi automaton} is similar to a non-deterministic pushdown automaton.
    It consists of:
    \begin{itemize}
        \item a set of states $Q$
        \item a finite alphabet $\Sigma$
        \item a transition function $\delta : Q \times \Sigma \to \Pp(Q)$
        \item an initial state $q_0 \in Q$
        \item a set of accepting state $F \subset Q$.
    \end{itemize}

    A \emph{run} of the automaton
    on a word $w \in \infseq{\Sigma}$
    is a sequence of states $r \in \infseq{Q}$
    such that $r_0 = q_0$ and for all $n \in \N, r_{n+1} \in \delta(r_n, w_n)$.

    The automaton accepts the word $w$ if there exists run on $w$
    visits an accepting state infinitely many times.

    The \w-language of an automaton is the set of words
    that are accepted by the automaton.
\end{definition}

\begin{definition}
    A \emph{deterministic Büchi automaton} is a Büchi automaton
    where the transition function is deterministic, that is,
    for all state $q \in Q$ and letter $l \in \Sigma$,
    $\abs{\delta(q, l)} \leq 1$.
\end{definition}


We say that a \w-language $L \subset \infseq{\Sigma}$ is
\emph{Büchi-definable} if there is a Büchi automaton
whose language is $L$.

\begin{lemma}\label{lemma:buchi-definable}
    A Büchi-definable \w-language is S1S-definable.
\end{lemma}

\begin{proof}
    Let $\Aa = (Q, \Sigma, \delta, q_1, F)$ be a Büchi automaton.
    We need to construct a formula $\phi(X_1, \dots, X_n)$
    such that for all \w-word $w \in \infseq{\Sigma}$
    we have $w \models \phi(X_1, \dots, X_n)$
    if and only if $\Aa$ accepts $w$.
    For this, we set $n := \abs{\Sigma}$ and \[
        \phi(X_1, \dots, X_n) =
            \exists Q_1, \dots, Q_{n} ~
            \phi_{part}
            \wedge
            \phi_{start}
            \wedge
            \phi_{trans}
            \wedge
            \phi_{accept}
    \]
    Informally, for each integer $t$ there is exactly one
    of the $Q_i$ such that $t \in Q_i$, which corresponds
    to the state of the automaton on an accepting run.
    Formally,
    \begin{itemize}
        \item $\phi_{part}$ asserts that the sets $Q_1, \dots, Q_{n}$
            form a partition of $\N$
            \[\phi_{part}(Q_1, \dots, Q_n) :=
                \forall t \bigvee_{i=1..n} Q_i(t)
                \wedge
                \forall t \bigwedge_{i \neq j}
                    \neg \parenthesis{Q_i(t) \wedge Q_j(t)}
            \]
        \item $\phi_{start}$ encodes the facts that a run
            must start at $q_1$, so \[
                \phi_{start}(Q_1, \dots, Q_n) := Q_1(0)
            \]
        \item $\phi_{trans}$ encodes the transition function.
            \[
                \phi_{trans}(Q_1, \dots, Q_n) =
                \forall t~
                \bigwedge_{q' \notin \delta(q, l)}
                    Q_q(t) \wedge X_l(t) \implies \neg Q_{q'}(t + 1)
            \]
            where the conjunction is on every triple $(q, l, q') \in
                Q \times \Sigma \times Q$ such that $q' \notin \delta(q, l)$.
            This corresponds to forbiding the automaton to
            move from the state $q$ to $q'$ by reading the letter $l$.
            Note that we do not need to explicitely require that the
            automato goes to some state in $\delta(q, l)$ as
            the fact that the $Q_i$ form a partition already require
            that the automaton goes to \textit{some} state.
        \item $\phi_{accept}$ encodes the fact that the automaton
            visits infinitely many times an accepting state:
            \[
                \phi_{accept}(Q_1, \dots, Q_n) =
                \forall t\, \exists s\, \Bigparenthesis{
                    t < s \wedge \bigwedge_{i \in F} Q_i(t)
                }
            \]
    \end{itemize}

    By construction, if there is an accepting run $r \in \infseq{Q}$
    then we have $w \models \phi(X_1, \dots, X_n)$ (where, remember, the $X_i$
    are interpreted as the set of integer where $w$ has the letter $i$).
    On the other side, if $w \models \phi$, an accepting run
    is given by the sets $Q_1, \dots, Q_{n}$ by $r_i = j$
    if and only if $i \in Q_j$. This is well defined because the $Q_i$
    form a partition of $\N$, and corresponds to an accepting run
    since it starts at $q_1$ (by $\phi_{start}$),
    moves according to the transition function (by $\phi_{trans}$)
    and visits infinitely many time an accepting state(by $\phi_{accept}$).
\end{proof}


We now show that we can build a Büchi automaton from
a S1S formula. Combined with the previous lemma, we obtain

\begin{theorem}
    An \w-language is Büchi-definable if and only if
    it is S1S definable.
\end{theorem}

\begin{proof}
    Let $L$ be an \w-language. By \autoref{lemma:buchi-definable},
    we know that if it is Büchi-definable, it is S1S-definable.

    Now, let $\phi(X_1, \dots, X_n)$ be a S1S formula.
    We show that there is a Büchi automaton on the language $\IB^n$
    recognising this language by induction on the height of $\phi$.

\end{proof}




























\iffalse
\section{Introduction}

\subsection{The parity game}
\begin{definition}
    The \emph{parity game} is an inifinite two player game
    played on a directed graph $G = (V, E)$. Let $V_0, V_1$
    be a partition of the vertices of $G$, and $p: V \to \N$
    any function, called the \emph{priority function}.
    Let also $v_0 \in V$ be the strating point of the game.

    The game goes as follows:
    \begin{itemize}
        \item It starts at $v_0$
        \item At a given turn $i$, if $v_i \in V_0$,
            player 0 decides to move to an adjacent node
            $v_{i+1}$. Otherwise if $v_i \in V_1$, it is
            player 1 that picks a neighbourg.
        \item After $\w$ turns, they produce a sequence of vertices
            $(v_n)_{n \in \N} \in V$. Let $V^\infty$ be the set of
            vertices that have been visited infinitely many times.
            If $\max \setst{p(v)}{v \in V^\infty}$ is even, player 0
            wins. If it is odd, player 1 wins.
    \end{itemize}
\end{definition}

\[
    W = \setst{b \in T}{
        \exists z \in V ~ \forall z' \in V \left(
            \begin{array}{c}
                p(z) \even
                \\ \wedge \\
                \existsinf i,~ v_i = z
                \\ \wedge \\
                p(z') > p(z) \implies \exists N \forall n > N v_n \neq z'
            \end{array}
        \right)
    }
\]
\fi

\newpage
\nocite{*}
\bibliographystyle{apalike}
\bibliography{bibliography.bib}


\end{document}