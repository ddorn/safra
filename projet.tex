\input{../preambule.tex}

\title{Modal logic, $\mu$-calcul, parity games and others}
\author{Diego Dorn}

\newcommand{\infiniteWords}{\infseq{(\IB^n)}}
\newcommand{\Sing}{\mathrm{Sing}}
\newcommand{\Succ}{\mathrm{Succ}}
\newcommand{\spacedAutomata}[1]{\begin{center}
\begin{tikzpicture}[automata, node distance=90pt]
#1
\end{tikzpicture}
\end{center}}

\begin{document}

\maketitle

\section{Beyond first order logic}

The goal of this section is to introduce the reader
to some extensions of first order logic (FO),
and most importantly to develop monadic second order logic.

\subsection{Second order logic}

In first order logic, quantifications happen only over the
domain elements.
Second order logic (SO) is a generalization of FO,
where quantification over relations are allowed.
It adds second order variables, usually denoted by capital
letters, that are interpreted by relations, that is,
if the relation is of arity $n$, subsets of $\Mm^n$.

For instance, the following formula are syntaxically valid:
\begin{itemize}
    % \item $\forall P~ \exists x~ \forall y~ P(x) \implies P(y)$,
    %     where $P$ is a variable of arity $1$.
    \item If the language contains the symbol $\leq$
        and $A$ is a second order variable of arity 1, then:
    \[
        \forall A ~ \exists x ~
            (A(x) \implies \forall y ~
                (A(y) \implies x \leq y)
    \]
        is a formula expressing that every subset of the model
        a has a minimal element.
    \item If the language contains a binary relation $E$
        and $M$ is a second order variable of arity 2,
        consider
        \[
            \exists M\, \forall x\, \forall y \,
            \bigparenthesis{M(x, y) \implies E(x, y)}
            \wedge \forall x \, \exists! y \, M(x, y).
        \]
        If $E$ is symetrical, we can view any model as an
        undirected graph with edges given by $E$, then
        the formula above express the fact that
        there exists a perfect matching, namely $M$.
\end{itemize}

\begin{definition}
    Given a vocabulary $\sigma$ consisting of relations
    and constants symbols,
    the \emph{terms} of SO are constants symbols and first order variables.

    The \emph{atomic formulas} are of the form:
    \begin{itemize}
        \item $t = t'$ when $t, t'$ are terms.
        \item $R(t_1, \dots, t_n)$ when $t_1, \dots, t_n$ are terms
            and $R \in \sigma$ is a relation of arity $n$.
        \item $X(t_1, \dots, t_n)$ when $t_1, \dots, t_n$ are terms
            and $X$ is a second-order variable of arity $n$.
    \end{itemize}

    The set of SO \emph{formulas} is the smallest set that contains
    all atomic formulas and is closed under:
    \begin{itemize}
        \item boolean operators: $\neg$, $\wedge$, $\vee$ and first order quantification
        \item second order quantification: if $\phi(\vec{x}, Y, \vec{X})$
            is a SO formula, then $\forall Y \phi(\vec{x}, Y, \vec{X})$
            and $\exists Y \phi(\vec{x}, Y, \vec{X})$ are SO formulas.
    \end{itemize}

    The \emph{semantic} of SO logic is defined similarly to FO logic
    so we only need to define the semantic for new constructs.
    Let $\Mm$ be a $\s$-structure and $\phi(x_1, \dots, x_k, X_1, \dots, X_n)$
    a SO formula. We define $\Mm \models \phi(\vec{b}, \vec{B})$
    where $b \in \Mm^k$ is a tuple of elements of $\Mm$
    and if $X_i$ is of arity $n_i$, then $B_i$ is a subset of $\Mm^{n_i}$.

    \begin{itemize}
        \item If $\phi(x_1, \dots, x_k, X)$ is $X(t_1, \dots, t_n)$
            with $X$ a second-order variable of arity $n$
            and $t_1, \dots, t_n$ terms with free variables
            among $x_1, \dots, x_i$, then
            $\Mm \models \phi(\vec{b}, B)$
            if $(t_1^\Mm\vec{b}), \dots, t_k^\Mm(\vec{b}))$ is in $B$.
        \item If $\phi(\vec{x}, Y, \vec{X})$ is $\forall Y \psi(\vec{x}, Y, \vec{X})$
            with $Y$ a second-order variable of arity $n$
            then $\Mm \models \phi(\vec{b}, B)$
            if for all $C \subseteq \Mm^n$, $\Mm \models \psi(\vec{x}, C, \vec{X})$
        \item If $\phi(\vec{x}, Y, \vec{X})$ is $\exists Y \psi(\vec{x}, Y, \vec{X})$
            with $Y$ a second-order variable of arity $n$
            then $\Mm \models \phi(\vec{b}, B)$
            if for some $C \subseteq \Mm^n$, $\Mm \models \psi(\vec{x}, C, \vec{X})$
    \end{itemize}
\end{definition}

We will not study much of second order logic, but instead
look at one of its fragment, monadic second order logic.

\subsection{Monadic second order logic}

Monadic second order logic, or MSO is an extension of
fisrt order logic and a restriction of second order logic.
In MSO, valid formulas are formulas of second order logic
where second order quantification happens only on unary relations.
This corresponds to be able to quantify over elements
of the domain (first-order quantification)
or over subsets of the domain (second-order quantification).

The semantics of MSO are the same as SO semantics.

% There are two things that are remarkable about
% this logic, when considered together:
% \begin{itemize}
%     \item MSO is very expressive. It can for instance
%         describe problems at every level of the polynomial hierarchy ($\PHierachy$).
%     \item MSO is decidable for a large class of models, for instance
%         infinte strings and trees.
% \end{itemize}


\subsection{S1S: infinite strings in MSO}

The decidability problem for monadic second order logic
in general is impossible, because it contains first order logic.
However, in monadic second order logic, the theory of \N with
the successor (S1S) has been shown to be decidable.
This theory is also called the theory of inifinite strings
for reasons that will be clear in the next section.

\begin{definition}
    Let $n \in \N$ be a positive integer.
    A \emph{language}  of S1S is $\Ll = \set{\Symbol{0}, \Symbol{S}, \Symbol{<}, \Symbol{P_1}, ..., \Symbol{P_n}}$,
    where $0$ is a constant symbol, $S$ is a unary function,
    $<$ is a binary relation, and the $P_i$ are unary relations.

    Let $P_1, \dots, P_n \subset \N$. A model of S1S is
    $\Mm = \set{\N, 0, +1, <, P_1, ..., P_n}$,
    where the domain is always \N, $S^\Mm = +1$ is the successor function
    which maps $x$ to $x+1$, $<^\Mm = <$ is interpreted as the usual order
    on \N, and $P_i^\Mm = P_i$.

\end{definition}

\begin{remark}
To get a model of S1S, we only need to give the sets $P_1, \dots, P_n$.
Therefore, a model can be coded by an \w-word $\Pp \in \infseq{(\IB^n)}$
where $i \in P_k \iff (\Pp_i)_k = 1$.

In other words, each letter of the \w-word $\Pp$ is a $n$-tuple of
$0$'s and $1$'s, and if the $k$-th element of $i$-th letter is a 1,
then $P_i(k)$ holds.
\end{remark}

The reason why S1S is often called the theory of infinite strings
is because if for each $i \in \N$, there is exactly
one of the $\P_1(i), \dots, P_n(i)$, then
we can represent the model as an infinite string
on the alphabet $\Sigma = \set{P_1, \dots, P_n}$.

\paragraph{}
The semantics of S1S are the same as MSO. In particular,
we use \N as the universe for first order variables
and $2^\N$ as the universe for second order variables.
If $w \in \infiniteWords$ is an infinite word inducing
the model $\Mm = \set{\N, 0, +1, <, P_1, ..., P_n}$,
and $\phi(X_1, \dots, X_n)$
is a S1S formula with $n$ free second order variables,
we write \[
    w \models \phi(X_1, \dots, X_n)
    ~~\iff~~
    \Mm \models \phi_{[P_1/X_1, \dots, P_n/X_n]}
\]

\begin{definition}
    An \w-language $L \subset \infseq{(\IB^n)}$ is
    \emph{S1S-definable} if there is some S1S formula
    $\phi(X_1, \dots, X_n)$ such that
\[
    L = \setst{w \in \infseq{(\IB^n)}}{
        w \models \phi(X_1, \dots, X_n)
    }
\]
\end{definition}

\begin{example}
    $L = \setst{w \in \infseq{\IB}}{w \text{ has infinitly many 1's}}$
    is first order definable by
    $\phi(X_1) = \forall s\, \exists t\, (s < t \wedge X_1(t))$
\end{example}




\begin{definition}
    A \emph{Büchi automaton} is similar to a non-deterministic pushdown automaton.
    It consists of:
    \begin{itemize}
        \item a set of states $Q$
        \item a finite alphabet $\Sigma$
        \item a transition function $\delta : Q \times \Sigma \to \Pp(Q)$
        \item an initial state $q_0 \in Q$
        \item a set of accepting state $F \subset Q$.
    \end{itemize}

    A \emph{run} of the automaton
    on a word $w \in \infseq{\Sigma}$
    is a sequence of states $r \in \infseq{Q}$
    such that $r_0 = q_0$ and for all $n \in \N, r_{n+1} \in \delta(r_n, w_n)$.

    The automaton accepts the word $w$ if there exists run on $w$
    visits an accepting state infinitely many times.

    The \w-language of an automaton is the set of words
    that are accepted by the automaton.
\end{definition}

\begin{definition}
    A \emph{deterministic Büchi automaton} is a Büchi automaton
    where the transition function is deterministic, that is,
    for all state $q \in Q$ and letter $l \in \Sigma$,
    $\abs{\delta(q, l)} \leq 1$.
\end{definition}


We say that a \w-language $L \subset \infseq{\Sigma}$ is
\emph{Büchi-definable} if there is a Büchi automaton
whose language is $L$.

\begin{lemma}\label{lemma:buchi-definable}
    A Büchi-definable \w-language is S1S-definable.
\end{lemma}

\begin{proof}
    Let $\Aa = (Q, \Sigma, \delta, q_1, F)$ be a Büchi automaton.
    We need to construct a formula $\phi(X_1, \dots, X_n)$
    such that for all \w-word $w \in \infseq{\Sigma}$
    we have $w \models \phi(X_1, \dots, X_n)$
    if and only if $\Aa$ accepts $w$.
    For this, we set $n := \abs{\Sigma}$ and \[
        \phi(X_1, \dots, X_n) =
            \exists Q_1, \dots, Q_{n} ~
            \phi_{part}
            \wedge
            \phi_{start}
            \wedge
            \phi_{trans}
            \wedge
            \phi_{accept}
    \]
    Informally, for each integer $t$ there is exactly one
    of the $Q_i$ such that $t \in Q_i$, which corresponds
    to the state of the automaton on an accepting run.
    Formally,
    \begin{itemize}
        \item $\phi_{part}$ asserts that the sets $Q_1, \dots, Q_{n}$
            form a partition of $\N$
            \[\phi_{part}(Q_1, \dots, Q_n) :=
                \forall t \bigvee_{i=1..n} Q_i(t)
                \wedge
                \forall t \bigwedge_{i \neq j}
                    \neg \parenthesis{Q_i(t) \wedge Q_j(t)}
            \]
        \item $\phi_{start}$ encodes the facts that a run
            must start at $q_1$, so \[
                \phi_{start}(Q_1, \dots, Q_n) := Q_1(0)
            \]
        \item $\phi_{trans}$ encodes the transition function.
            \[
                \phi_{trans}(Q_1, \dots, Q_n) =
                \forall t~
                \bigwedge_{q' \notin \delta(q, l)}
                    Q_q(t) \wedge X_l(t) \implies \neg Q_{q'}(t + 1)
            \]
            where the conjunction is on every triple $(q, l, q') \in
                Q \times \Sigma \times Q$ such that $q' \notin \delta(q, l)$.
            This corresponds to forbiding the automaton to
            move from the state $q$ to $q'$ by reading the letter $l$.
            Note that we do not need to explicitely require that the
            automato goes to some state in $\delta(q, l)$ as
            the fact that the $Q_i$ form a partition already require
            that the automaton goes to \textit{some} state.
        \item $\phi_{accept}$ encodes the fact that the automaton
            visits infinitely many times an accepting state:
            \[
                \phi_{accept}(Q_1, \dots, Q_n) =
                \forall t\, \exists s\, \Bigparenthesis{
                    t < s \wedge \bigwedge_{i \in F} Q_i(t)
                }
            \]
    \end{itemize}

    By construction, if there is an accepting run $r \in \infseq{Q}$
    then we have $w \models \phi(X_1, \dots, X_n)$ (where, remember, the $X_i$
    are interpreted as the set of integer where $w$ has the letter $i$).
    On the other side, if $w \models \phi$, an accepting run
    is given by the sets $Q_1, \dots, Q_{n}$ by $r_i = j$
    if and only if $i \in Q_j$. This is well defined because the $Q_i$
    form a partition of $\N$, and corresponds to an accepting run
    since it starts at $q_1$ (by $\phi_{start}$),
    moves according to the transition function (by $\phi_{trans}$)
    and visits infinitely many time an accepting state(by $\phi_{accept}$).
\end{proof}

We will later show that the converse is also true,
that is, given some S1S-decidable language,
we can build a Büchi automaton that recognises the same
language. The two notions are therfore equivalent.

To that extent, we will introduce deterministic Muller
automata and show that they are equivalent to (non-deterministic)
Büchi automatons. This will be used to show
that it is possible to complement a Büchi automaton.
We will then show that S1S is equivalent
to a simpler version with less constructs, $\text{S1S}_0$.
Finally, we will show that Büchi automata are as expressive
as $\text{S1S}_0$ formulas.


\begin{definition}
    A formula is a $\text{S1S}_0$ formula if
    \begin{itemize}
        \item its atomic formulas are one of $X \subseteq Y$,
            $\Succ{X, Y}$ or $\Sing{X}$, for $X$ and $Y$ some second
            order variable. We interpret that $X \subseteq Y$ holds
            if $X$ is a subset of $Y$, $\Succ(X, Y)$ holds if
            $(X, Y) = (\set{a}, \set{a+1})$ for some $a \in \N$ and
            $\Sing(X)$ holds if $X = \set{a}$ for some $a$.
        \item The only connectors are $\vee$ and $\neg$
        \item The only quantifiers are second order existential quantifers.
    \end{itemize}
\end{definition}

\begin{lemma}
    \label{lemma:s1s-is-s1s-0}
    Every S1S formula $\phi(X_1, \dots, X_n)$ has
    an equivalent $\text{S1S}_0$ formula $\phi_0(X_1, \dots, X_n)$.
\end{lemma}

\begin{proof}
    First, we know that we can eliminate all conjunction with De Morgan's
    laws and replace all impliations with their definition. Similarly, we can eliminate universal quantifers
    since $\forall x \psi(x) \iff \neg \exists x \neg \psi(x)$.

    We can eliminate the constant $0$, by using a fresh variable (say $z$)
    that does not appear in $\phi$. Then, $\phi$ is equivalent to
    \[
        \exists z~ \bigparenthesis{\neg\exists x\, (x < z) \wedge \phi_{[z/0]}}
    \]
    where $\phi_{[z/0]}$ is the formula where every 0 of $\phi$ is replaced by $z$.

    The formula $x < y$ is equivalent to \[
        \forall X~ \Bigparenthesis{
            X(x) \wedge \forall t \bigparenthesis{X(t) \implies X(S(t))}
        } \implies X(y)
    \]
    That is, every set that contains $x$ and is closed under the successor
    function also contains $y$.

    Then we can ensure that the successor function occurs only
    in formulas of the form $S(x) = y$. For instance,
    we replaces instances of $X(S(S(x)))$ by \[
        \exists s \exists t \bigparenthesis{
            S(x) = s \wedge S(s) = t \wedge X(t)
        }
    \]
    We can similarly remove all instances of the form $S(...(S(x)...) = S(...(S(y)...)$
    by adding intermediate variables.

    We have shown so far that we can consider formulas
    that constist only of $S(x) = y$, $X(x)$, connectors $\neg$ and $\wedge$
    and first and second order existential quantifers.
    In order to remove completely first order variables and quantifers,
    we need to modify at the same time every occurence of first order variables:
    \begin{itemize}
        \item If $\phi$ is of the form $\exists x \psi(x)$, we replace it by
            $\exists X ~ \Sing(X) \wedge \psi_{[X/x]}$ where $X$ is a variable not apearing
            in $\psi$.
        \item If $\phi$ is $X(y)$, we replace it by $\Sing(Y) \wedge Y \subseteq X$
        \item If $\phi$ is $x' = y$ we replace it by $\Succ(x, y)$.
    \end{itemize}
\end{proof}

\begin{theorem}
    An \w-language is Büchi-definable if and only if
    it is S1S definable.
\end{theorem}

\begin{proof}
    Let $L$ be an \w-language. By \autoref{lemma:buchi-definable},
    we know that if it is Büchi-definable, it is S1S-definable.

    For the other direction, will show only for the case
    where the alphabet is $\IB = \set{0, 1}$ as the proof
    in the general case adds only more verbose formalism and no new ideas.

    By \autoref{lemma:s1s-is-s1s-0}, formulas of S1S
    are as expressive as formulas of $\text{S1S}_0$,
    so it suffices construct a Büchi automaton
    that corresponds each $\text{S1S}_0$ formula.
    We consider formulas of the form
    $\phi(P, X_1, \dots, X_m)$
    where \begin{itemize}
        \item the $P$ is a second order variable that will
            represent the positions of the \w-word where there is a 1.
        \item the $X_i$ are second order free variables.
    \end{itemize}
    We will abreviate this as $\phi(P, \vec X)$,
    and for each such formula, we construct an equivalent
    automaton on the language $\IB \times \IB^m = \IB^{m+1}$.
    By equivalent, we mean that $\phi$ holds when given any $P, \vec X$
    if and only if the automaton accepts the word $(P, \vec X)$.

    We proceed by induction on the height of the formula $\phi$.

    \begin{itemize}
        \item yes.
    \end{itemize}



    \begin{itemize}
        \item If $\phi(P, x, y)$ is $x = y$, an automaton
            that recognises the language $\IB^3$ is
            \begin{center}
            \begin{tikzpicture}[automata, node distance=90pt]
                \node[state, initial] (q0) at (0, 0) {};
                \node[state, accepting] (q1) [right of=q0] {};
                \draw (q0)
                    edge node {$(*, 1, 1)$} (q1)
                    edge [loop above] node {$(*, 0, 0)$} (q0)
                    (q1)
                    edge [loop above] node {$(*, 0, 0)$} (q1)
                    ;
            \end{tikzpicture}
            \end{center}
            where the wildcard * means that the value in that coordinate
            is ignored.
            This construction ensures that the only way a word is recognised
            is if its second and third coordinates consist only of zeros,
            except in one place where they are both one.
        \item If $\phi(P, x, y)$ is $S(x) = y$, we want that the only 1
            in the second coordinate appears just before
            the 1 in the second.
            \spacedAutomata{
                \node[state, initial] (q0) at (0, 0) {};
                \node[state] (q1) [right of=q0] {};
                \node[state, accepting] (q2) [right of=q1] {};

                \draw (q0) edge [loop above] node {$(*, 0, 0)$} (qo)
                    edge node {$(*, 0, 1)$} (q1)
                    (q1) edge node {$(*, 1, 0)$} (q2)
                    (q2) edge [loop above] node {$(*, 0, 0)$} (q2);
            }
        \item If $\phi(P, x, y)$ is $S^a(x) = S^b(y)$,
            where $S^a$ is the successor function applied $a$ times,
            we can assume that $a < b$ (otherwise we consider $S^b(y) = S^a(x)$).

    \end{itemize}

\end{proof}




























\iffalse
\section{Introduction}

\subsection{The parity game}
\begin{definition}
    The \emph{parity game} is an inifinite two player game
    played on a directed graph $G = (V, E)$. Let $V_0, V_1$
    be a partition of the vertices of $G$, and $p: V \to \N$
    any function, called the \emph{priority function}.
    Let also $v_0 \in V$ be the strating point of the game.

    The game goes as follows:
    \begin{itemize}
        \item It starts at $v_0$
        \item At a given turn $i$, if $v_i \in V_0$,
            player 0 decides to move to an adjacent node
            $v_{i+1}$. Otherwise if $v_i \in V_1$, it is
            player 1 that picks a neighbourg.
        \item After $\w$ turns, they produce a sequence of vertices
            $(v_n)_{n \in \N} \in V$. Let $V^\infty$ be the set of
            vertices that have been visited infinitely many times.
            If $\max \setst{p(v)}{v \in V^\infty}$ is even, player 0
            wins. If it is odd, player 1 wins.
    \end{itemize}
\end{definition}

\[
    W = \setst{b \in T}{
        \exists z \in V ~ \forall z' \in V \left(
            \begin{array}{c}
                p(z) \even
                \\ \wedge \\
                \existsinf i,~ v_i = z
                \\ \wedge \\
                p(z') > p(z) \implies \exists N \forall n > N v_n \neq z'
            \end{array}
        \right)
    }
\]
\fi

\newpage
\nocite{*}
\bibliographystyle{apalike}
\bibliography{bibliography.bib}


\end{document}